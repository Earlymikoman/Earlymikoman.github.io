<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Academic</title>
    <style>
  /* The outer navbar container â€“ this is what becomes sticky */
  .navbar-container {
    background-color: #f8f8f8;        /* light background so content doesn't show through */
    padding: 10px 20px;               /* some breathing room */
    position: sticky;                 /* <-- This makes it follow scrolling */
    top: 0;                           /* sticks to the very top */
    z-index: 1000;                    /* stays on top of page content */
    box-shadow: 0 2px 8px rgba(0,0,0,0.1); /* optional subtle shadow */
    text-align: left;
  }

  /* Keep dropdowns in a horizontal row */
  .dropdown {
    position: relative;
    display: inline-block;
    margin-right: 20px;               /* space between top-level items */
  }

  .dropbtn {
    font-size: 16px;
    padding: 8px 12px;
    cursor: pointer;
    background: #eee;
    border: 1px solid #ccc;
    border-radius: 4px;
    display: inline-block;
  }

  .dropbtn:hover {
    background-color: #ddd;
  }

  .dropdown-content {
    display: none;
    position: absolute;
    left: 0;
    top: 100%;
    background-color: white;
    min-width: 160px;
    box-shadow: 0px 8px 16px rgba(0,0,0,0.2);
    border-radius: 4px;
    overflow: hidden;
  }

  .dropdown-content a {
    color: black;
    padding: 10px;
    text-decoration: none;
    display: block;
  }

  .dropdown-content a:hover {
    background-color: #ddd;
  }

  .dropdown:hover .dropdown-content {
    display: block;
  }
</style>

<div class="navbar-container">

  <div class="dropdown">
    <div class="dropbtn">
    <a href="/index.html">Home</a>
</div>
</div>

<div class="dropdown">
    <div class="dropbtn"><a href="/CopyFiles/Academic/AcademicPage/">Academic</a></div>
    <div class="dropdown-content">
      <a href="/CopyFiles/Academic/AcademicPage/#Last Contact">Last Contact</a>
      <a href="/CopyFiles/Academic/AcademicPage/#Sciophobia">Sciophobia</a>
    </div>
</div>

    <div class="dropdown">
        <div class="dropbtn"><a href="/CopyFiles/Personal/PersonalPage/">Personal</a></div>
        <div class="dropdown-content">
            <a href="/CopyFiles/Personal/PersonalPage/#Noirish">Noirish</a>
            <a href="/CopyFiles/Personal/PersonalPage/#Excalibur Engine">Excalibur Engine</a>
            <!--<a href="/Personal/PersonalPage/">Weave</a>-->
        </div>
    </div>

</div>
    <link rel="stylesheet" href="style.css">
</head>



<body>
    <div id="site-header"></div>
    
    <main>

        <section id="Last Contact">
        

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Last Contact</title>
    <link rel="stylesheet" href="style.css">
</head>

<style>
  video {
    display: block;      /* Required for margin auto to work */
    margin: 0 auto;      /* Centers horizontally */
    max-width: 100%;     /* Responsive on small screens */
    height: auto;
  }
</style>

<body>

    <header>
        <h1>Last Contact</h1>
    </header>

    <main>
        <video controls width="800" height="450">
            <source src="/CopyFiles/Academic/Last Contact/GAM150_LastContact_Trailer.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>
        <p>
            Last Contact was my freshman game project, developed by the team Mod2 in C++:
            <ul>
                <li>Xander Boosinger</li>
                <li>Ori Balashov</li>
                <li>Elliot Orr</li>
                <li>Justin Ptacek</li>
                <li>Aidan Hartman</li>
            </ul>

            &nbsp;&nbsp;&nbsp;&nbsp;Last Contact being my first "real" project, a lot of our time was
             spent designing a fairly basic engine; lots of figuring out needling
             stuff like when to delete components,
             how to do update/render layers, how to render, how to separate component
             responsibilities cleanly.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;Aside from that though, my biggest tasks were to implement the
             core mechanic, trains/tracks, and the user interface for placing those
             as such. I had started the semester
             thinking the trains would be easy, but I soon found that there were a
             number of edge cases I had to watch for, and I was really trying
             to get away with a any-time method;
             effectively, determining the direction the train should go on tracks
             based on the current status of both, rather than trying to maintain
             some kind of record to help determine the direction.
            <br>
            <br>&nbsp;&nbsp;&nbsp;&nbsp;The method I eventually went for to achieve was a bit
             hacked-together, but wound up working very well for the final project,
             and I'm not currently aware of any bugs
             relating to this code at the moment. More annoying than this,
             though, was the interface for placing the tracks; the UI itself
             was mostly fine, some memory bugs here and there,
             but what was really terrible was the logic for which way placed
             tracks should be pointing; this involved a lot of recursive
             searching in the tiles around the placed track,
             and took quite a lot of debugging to iron out the kinks.
             I believe there are definitely edge cases out there that
             would cause weird behaviour, but I can't come up with a
             specific example. I just know in my soul SOMETHING is probably broken.
            <br>
            <br>&nbsp;&nbsp;&nbsp;&nbsp;I used FMOD for the game's audio, and since I'd never used FMOD
             at all before it turned out pretty basic; pretty much, just PlaySound.
             I did a little bit more to get the audio
             to dropoff when the camera was far away from the source, but this was
             really cobbled together. I also made the music and processed the SFX,
             but the music was a bit janky and
             SFX processing isn't all too interesting to write about here.

            
        </p>
        <a href="/CopyFiles/Academic/Last Contact/LAST CONTACT Setup.zip" download>Installer Download</a>
    </main>
    
</body>

</html>
        </section>

        <section id="Sciophobia">
        

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sciophobia</title>
    <link rel="stylesheet" href="style.css">
</head>



<body>

    <header>
        <h1>Sciophobia</h1>
    </header>

    <main>
        <p>
            Sciophobia is my sophomore game project, developed by the team 2BDetermined in C++:
            <ul>
                <li>Xander Boosinger</li>
                <li>Jackson Miller</li>
                <li>Veronica Stever</li>
                <li>Zach Rojas</li>
                <li>Tyler Andrews</li>
            </ul>

            &nbsp;&nbsp;&nbsp;&nbsp;Currently it's the middle of the school year
             (as of 12/14/2025), so Sciophobia is still in development.
             What is mostly finished however, is the engine.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;I wound up doing a bit of working on most
             everything, but my primary focus so far has been developing the core
             engine components and the editor for the engine.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;The engine, nominally dubbed the
             Lighthouse engine, is a partial ECS system wherein components are stored
             disparately as pointers,
             and are managed not by entities but by component systems.
             The reason for the components being stored as pointers
             instead of as contiguous data is that for our purposes
             pointers were simpler to work with, though if we ever need
             the efficiency again it should be relatively easy to convert to
             contiguous data storage.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;Download the
             <a href="/CopyFiles/Academic/Sciophobia/Lighthouse Engine Tech Guide.pdf" download>
                Tech Guide
            </a>
             for a broader overview
             of the engine.
            <br>
            <br>
            <img
                src="/CopyFiles/Academic/Sciophobia/Lighthouse Engine Architecture Diagram.drawio.png" 
                alt="Engine Diagram" 
                style="display: block; margin: 0 auto; max-width: 100%; height: 50vh;">
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;The editor is the lion's share of what
             I have done on this project so far, and my primary goal for
             it was for it to be dynamic;
             i.e., for it to be able to show and edit any component,
             without a special method like CreateEditorSection. It just
             so happened we had a suitable method for each component
             in our Serialization code, which I decided to hijack for the editor.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;Effectively, to show the components it
             simply iterates over the json file generated by the component's
            Serialization method, and displays the lowest-levels as ImGui text
             and an ImGui TextInput, and to edit said component, it just edits
             the json of the component to reflect
             user changes and then deserializes that into the component.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;There are some asterisks, particularly with pointers,
             but as long as the Serialization/Deserialization functions
             present the data in a reasonable way
             (for example, showing resource pointers as strings in the json,
             and in deserialization using that string to get the actual pointer),
             it works quite well. There is also a
             carveout for dynamic arrays, but that's a bit nitty-gritty.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;There are some more ImGui things I did, mostly debug,
             but that's the most interesting thing.
            <br>
            <br>
            <img
                src="/CopyFiles/Academic/Sciophobia/Editor Screenshot.png" 
                alt="Editor Snapshot" 
                style="display: block; margin: 0 auto; max-width: 100%; max-height: 75vh;">
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;I also handled the audio. I personally much prefer making
             my own stuff to dealing with libraries when possible, so when
             I had to work with FMOD I effectively learned the bare minimum to
             "play a sound", and then worked on top of that.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;Still, I wanted dynamic audio that would be able
             to built on top of to eventually have fancy things like multiple
             listeners, environment-dependent effects,
             and all those fun things, so audio was a bit of a challenge
             to do like this. Nevertheless, what I landed on was to
             have AudioSources and AudioListeners
             (much like Unity, which is to an extent what I was
             basing my audio model off of), where AudioSources would
             spawn AudioInstances, which are what AudioListeners would listen for.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;In the future, I want to add raycasting (or possibly wavecasting,
             I need to do more research) to the game's audio, and learn FMOD's
             interface for bineural audio.
             This kind of precise audio should be able to give our relatively
             low-light game the ability to give players information in a non-visual way.
        </p>

        <a href="/CopyFiles/Academic/Sciophobia/Sciophobia_Setup.zip" download>Installer Download</a>
    </main>
    
</body>

</html>
        </section>

    </main>
    <footer>
        <p>&copy; 2025 Xander Boosinger</p>
    </footer>
</body>

</html>