

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sciophobia</title>
    <link rel="stylesheet" href="style.css">
</head>



<body>

    <header>
        <h1>Sciophobia</h1>
    </header>

    <main>
        <p>
            Sciophobia is my sophomore game project, developed by the team 2BDetermined in C++:
            <ul>
                <li>Xander Boosinger</li>
                <li>Jackson Miller</li>
                <li>Veronica Stever</li>
                <li>Zach Rojas</li>
                <li>Tyler Andrews</li>
            </ul>

            &nbsp;&nbsp;&nbsp;&nbsp;Currently it's the middle of the school year
             (as of 12/14/2025), so Sciophobia is still in development.
             What is mostly finished however, is the engine.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;I wound up doing a bit of working on most
             everything, but my primary focus so far has been developing the core
             engine components and the editor for the engine.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;The engine, nominally dubbed the
             Lighthouse engine, is a partial ECS system wherein components are stored
             disparately as pointers,
             and are managed not by entities but by component systems.
             The reason for the components being stored as pointers
             instead of as contiguous data is that for our purposes
             pointers were simpler to work with, though if we ever need
             the efficiency again it should be relatively easy to convert to
             contiguous data storage.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;Download the
             <a href="/CopyFiles/Academic/Sciophobia/Lighthouse Engine Tech Guide.pdf" download>
                Tech Guide
            </a>
             for a broader overview
             of the engine.
            <br>
            <br>
            <img
                src="/CopyFiles/Academic/Sciophobia/Lighthouse Engine Architecture Diagram.drawio.png" 
                alt="Engine Diagram" 
                style="display: block; margin: 0 auto; max-width: 100%; height: 50vh;">
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;The editor is the lion's share of what
             I have done on this project so far, and my primary goal for
             it was for it to be dynamic;
             i.e., for it to be able to show and edit any component,
             without a special method like CreateEditorSection. It just
             so happened we had a suitable method for each component
             in our Serialization code, which I decided to hijack for the editor.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;Effectively, to show the components it
             simply iterates over the json file generated by the component's
            Serialization method, and displays the lowest-levels as ImGui text
             and an ImGui TextInput, and to edit said component, it just edits
             the json of the component to reflect
             user changes and then deserializes that into the component.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;There are some asterisks, particularly with pointers,
             but as long as the Serialization/Deserialization functions
             present the data in a reasonable way
             (for example, showing resource pointers as strings in the json,
             and in deserialization using that string to get the actual pointer),
             it works quite well. There is also a
             carveout for dynamic arrays, but that's a bit nitty-gritty.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;There are some more ImGui things I did, mostly debug,
             but that's the most interesting thing.
            <br>
            <br>
            <img
                src="/CopyFiles/Academic/Sciophobia/Editor Screenshot.png" 
                alt="Editor Snapshot" 
                style="display: block; margin: 0 auto; max-width: 100%; max-height: 75vh;">
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;I also handled the audio. I personally much prefer making
             my own stuff to dealing with libraries when possible, so when
             I had to work with FMOD I effectively learned the bare minimum to
             "play a sound", and then worked on top of that.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;Still, I wanted dynamic audio that would be able
             to built on top of to eventually have fancy things like multiple
             listeners, environment-dependent effects,
             and all those fun things, so audio was a bit of a challenge
             to do like this. Nevertheless, what I landed on was to
             have AudioSources and AudioListeners
             (much like Unity, which is to an extent what I was
             basing my audio model off of), where AudioSources would
             spawn AudioInstances, which are what AudioListeners would listen for.
            <br>&nbsp;&nbsp;&nbsp;&nbsp;In the future, I want to add raycasting (or possibly wavecasting,
             I need to do more research) to the game's audio, and learn FMOD's
             interface for bineural audio.
             This kind of precise audio should be able to give our relatively
             low-light game the ability to give players information in a non-visual way.
        </p>

        <a href="/CopyFiles/Academic/Sciophobia/Sciophobia_Setup.zip" download>Installer Download</a>
    </main>
    
</body>

</html>